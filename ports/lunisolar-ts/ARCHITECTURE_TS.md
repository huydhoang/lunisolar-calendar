# Architecture: TypeScript Port (`lunisolar-ts`)

## 1. Purpose

`lunisolar-ts` is a TypeScript library that faithfully ports the Python lunisolar calendar engine. Rather than performing live astronomical calculations, it consumes **precomputed annual JSON data chunks** (new moons and solar terms) generated by the Python pipeline, making it suitable for browser, Node.js, and edge runtimes with no native dependencies.

---

## 2. Package Structure

```
ports/lunisolar-ts/
├── src/
│   ├── index.ts                  # Public API — all exports
│   ├── types.ts                  # Shared public types
│   ├── config.ts                 # Global runtime configuration
│   ├── core/
│   │   └── LunisolarCalendar.ts  # Core calendar engine
│   ├── data/
│   │   ├── DataLoader.ts         # Fetch / static data loading
│   │   └── manifest.ts           # Generated static import manifest
│   ├── huangdao/
│   │   ├── ConstructionStars.ts  # 12 Construction Stars (十二建星)
│   │   └── GreatYellowPath.ts    # Great Yellow Path (大黄道)
│   └── timezone/
│       └── TimezoneHandler.ts    # Intl-based timezone conversion
├── scripts/
│   ├── copy-data.mjs             # Copy JSON data chunks to dist/
│   ├── copy-data-to-src.mjs      # Copy JSON chunks into src/ for static builds
│   └── generate-data-manifest.mjs# Generate manifest.ts for static bundling
├── tests/
│   ├── lunisolar_compare.test.ts # Parity tests vs Python oracle
│   ├── huangdao_parity.test.ts   # Parity tests for huangdao systems
│   └── config.test.ts            # Configuration tests
├── examples/
│   └── run.mjs                   # Usage example
├── package.json
├── tsconfig.json
└── rollup.config.mjs
```

---

## 3. Module Descriptions

### 3.1. Entry Point (`src/index.ts`)

Exports the full public API:
- Classes: `LunisolarCalendar`, `DataLoader`, `TimezoneHandler`, `ConstructionStars`, `GreatYellowPath`
- Functions: `configure()`, `getConfiguration()`
- Types: all types from `types.ts` and `config.ts`

### 3.2. Configuration (`src/config.ts`)

Manages a global singleton config object. Consumers call `configure()` before using the library to set:

| Option | Type | Default | Description |
|---|---|---|---|
| `strategy` | `'fetch' \| 'static'` | `'fetch'` | Data loading strategy |
| `data.baseUrl` | `string` | jsDelivr CDN | Base URL for JSON data chunks |

`getConfiguration()` returns a shallow clone of the current config.

### 3.3. Data Loader (`src/data/DataLoader.ts`)

Abstracts over two data loading strategies behind a lazy-caching interface:

- **`'fetch'` strategy**: Downloads `{baseUrl}/{kind}/{year}.json` on demand. The default base URL is pinned to a version-specific jsDelivr CDN path (`lunisolar-ts@<VERSION>`). Supports Node.js `fs` for local file paths (Node 22+).
- **`'static'` strategy**: Uses `manifest.ts` (generated at build time) which contains static `import()` calls for each data chunk, enabling tree-shaking and offline bundling.

Both strategies use a `Map`-based memo cache keyed by `year` to avoid redundant fetches. Public methods:
- `getNewMoons(year: number): Promise<TNewMoon[]>` — unix timestamps in seconds
- `getSolarTerms(year: number): Promise<TSolarTerm[]>` — `[timestamp, termIndex]` pairs

### 3.4. Timezone Handler (`src/timezone/TimezoneHandler.ts`)

A thin wrapper around the browser-native `Intl.DateTimeFormat` API — no external timezone library required.

- `utcToTimezoneDate(utcDate: Date): TDateParts` — decomposes a UTC instant into local wall-clock parts
- `convertToTimezone(utcDate: Date): Date` — returns a `Date` whose UTC components equal the wall time in the target timezone (used for day-boundary logic)

### 3.5. Core Calendar (`src/core/LunisolarCalendar.ts`)

The central computation engine. Converts a Gregorian `Date` to a full lunisolar date with sexagenary cycle (ganzhi) for all four pillars.

**Algorithm — `fromSolarDate(date, timezone)`:**
1. Resolve local wall date via `TimezoneHandler`.
2. Load new moons and solar terms for the target year (± overlap) from `DataLoader`.
3. Identify principal solar terms (中气, one per month) and new moon timestamps.
4. Assign lunar month numbers anchored to the Winter Solstice month (子月, month 11) using the no-zhongqi leap rule.
5. Locate which `MonthPeriod` contains the input date to determine `lunarMonth`, `lunarYear`, `isLeapMonth`.
6. Compute the four ganzhi pillars:
   - `yearGanzhi()` — stem/branch from lunar year number
   - `monthGanzhi()` — stem determined by year stem × month index
   - `dayGanzhi()` — offset from anchor date 4 AD Jan 31 (Jiazi day)
   - `hourGanzhi()` — double-hour branch from local hour; stem from day stem + hour position

**`fromSolarDateRange(startDate, endDate, timezone)`:** Batch converts a date range efficiently, sharing ephemeris data across days.

**Immutable result properties:** `lunarYear`, `lunarMonth`, `lunarDay`, `isLeapMonth`, `yearStem`, `yearBranch`, `monthStem`, `monthBranch`, `dayStem`, `dayBranch`, `hourStem`, `hourBranch`, `isPrincipalSolarTermDay`.

### 3.6. Construction Stars (`src/huangdao/ConstructionStars.ts`)

Implements the 12 Construction Stars (十二建星) sequential algorithm.

**Calculation rules:**
- Each lunar month is associated with a *building branch* (月建) starting from 寅 at month 1.
- The base star for any day is `(dayBranch − monthBuildingBranch) mod 12`.
- **Solar term day rule**: on a day that is a principal solar term, repeat the previous day's star instead of advancing.
- For the first day of a month, the sequence is seeded by back-computing the day before.

**Scores and auspiciousness:**

| Star | 建 | 除 | 满 | 平 | 定 | 执 | 破 | 危 | 成 | 收 | 开 | 闭 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|
| Auspicious | ✗ | ✓ | ✓ | ✗ | ✓ | ✓ | ✗ | ✗ | ✓ | ✗ | ✓ | ✗ |
| Score | 2 | 4 | 3 | 2 | 4 | 3 | 1 | 2 | 3 | 2 | 3 | 1 |

**Public methods:**
- `calculateMonth(year, month, timezone): Promise<TDayInfo[]>` — compute stars for an entire solar month
- `getAuspiciousDays(year, month, minScore, timezone): Promise<TDayInfo[]>` — filter by minimum score

### 3.7. Great Yellow Path (`src/huangdao/GreatYellowPath.ts`)

Implements the Great Yellow Path (大黄道) / Black Path (大黑道) spirit calculator.

Each lunar month has a fixed *Azure Dragon start branch*. The spirit for a given day is determined by the offset `(dayBranch − azureDragonBranch) mod 12` into the 12-spirit sequence.

**Six Yellow Path spirits** (auspicious): 青龙, 明堂, 金匮, 天德, 玉堂, 司命  
**Six Black Path spirits** (inauspicious): 天刑, 朱雀, 白虎, 天牢, 玄武, 勾陈

**Public method:** `getSpirit(): TGreatYellowPathSpirit` — returns spirit name, path type, and description.

---

## 4. Data Flow

```
configure({ strategy, baseUrl })          ← optional, call once at startup
         │
         ▼
LunisolarCalendar.fromSolarDate(date, tz)
         │
         ├─ TimezoneHandler.utcToTimezoneDate()   resolve wall date/hour
         │
         ├─ DataLoader.getNewMoons(year)           fetch / import JSON
         ├─ DataLoader.getSolarTerms(year)         fetch / import JSON
         │         (results cached per year)
         │
         ├─ assign MonthPeriods + leap month
         ├─ yearGanzhi / monthGanzhi / dayGanzhi / hourGanzhi
         │
         └─► LunisolarCalendar (immutable result)
                    │
                    ├─► new ConstructionStars(cal).getStar()
                    └─► new GreatYellowPath(cal).getSpirit()
```

---

## 5. Build System

| Script | Tool | Description |
|---|---|---|
| `prebuild` | Node | Copy precomputed JSON data chunks; generate `manifest.ts` |
| `build` | Rollup | Bundle to ESM (`dist/index.mjs`) and CJS (`dist/index.cjs`); emit `.d.ts` |
| `postbuild` | Node | Copy JSON data chunks alongside the built dist |

The `__VERSION__` token in `DataLoader.ts` is replaced at build time by a Rollup `replace` plugin with the actual `package.json` version, pinning the CDN URL.

---

## 6. Public Types

| Type | Description |
|---|---|
| `TLunisolarDate` | Full lunisolar date + 8 sexagenary elements |
| `TSolarTerm` | `[unixSeconds, termIndex]` ephemeris record |
| `TNewMoon` | Unix timestamp in seconds |
| `TDateParts` | Broken-out wall-clock date parts |
| `TConstructionStar` | Star name, auspiciousness, score (0–100), description |
| `TDayInfo` | Calendar date paired with `TConstructionStar` |
| `TGreatYellowPathSpirit` | Spirit name, path type (`'yellow' \| 'black'`), description |
| `STAR_SEQUENCE` | Ordered tuple of 12 construction star characters |
| `DataLoaderStrategy` | `'fetch' \| 'static'` |
| `LunisolarOptions` | User-facing config shape for `configure()` |

---

## 7. Testing

Tests in `tests/` use **Vitest** and validate parity against the Python oracle by spawning the Python CLI directly:

| Test file | What it covers |
|---|---|
| `lunisolar_compare.test.ts` | Lunisolar date + all 4 ganzhi pillars vs Python for Asia/Shanghai, Asia/Ho_Chi_Minh, and day-boundary edge cases |
| `huangdao_parity.test.ts` | Construction Star name + Great Yellow Path spirit vs Python for multiple timezones and solar-term edge cases |
| `config.test.ts` | Configuration module behaviour |
